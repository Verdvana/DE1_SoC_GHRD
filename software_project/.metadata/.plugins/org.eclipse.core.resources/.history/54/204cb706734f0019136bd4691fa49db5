/*
 * main.c
 *
 *  Created on: 2019年3月5日
 *      Author: Verdvana
 */

//gcc标准头文件
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <string.h>

//hps 厂家提供的底层定义头文件
#define soc_cv_av	//定义使用soc_cv_av硬件平台

#include "hwlib.h"			//常量定义
#include "socal/socal.h"	//底层操作函数，如位、字节、半字、字的读写
#include "socal/hps.h"		//外设地址信息定义

//与用户具体HPS应用系统相关的硬件描述头文件
#include "hps_0.h"

//
#include "mpu.h"
#include "../inc/led.h"

/*
#define HW_REGS_BASE (ALT_STM_OFST )	//HPS外设地址段基地址  0xfc000000
#define HW_REGS_SPAN (0x04000000 )		//HPS外设地址段地址空间
#define HW_REGS_MASK (HW_REGS_SPAN - 1 )	//HPS外设地址段地址掩码

static volatile unsigned long *led_pio_virtual_base = NULL;	//led_pio虚拟地址
static volatile unsigned long *button_pio_virtual_base = NULL;	//button_pio虚拟地址

int fpga_init(long int *virtual_base) {
	int fd;
	void *periph_virtual_base;	//外设空间虚拟地址

	//打开MPU
	if ((fd = open("/dev/mem", ( O_RDWR | O_SYNC))) == -1) {
		printf("ERROR: could not open \"/dev/mem\"...\n");
		return (1);
	}

	//将外设地址段映射到用户空间
	periph_virtual_base = mmap( NULL, HW_REGS_SPAN, ( PROT_READ | PROT_WRITE),
			MAP_SHARED, fd, HW_REGS_BASE);
	if (periph_virtual_base == MAP_FAILED) {
		printf("ERROR: mmap() failed...\n");
		close(fd);
		return (1);
	}

	//映射得到led_pio外设虚拟地址
	led_pio_virtual_base = periph_virtual_base
			+ ((unsigned long) ( ALT_LWFPGASLVS_OFST + LED_PIO_BASE)
					& (unsigned long) ( HW_REGS_MASK));
	//映射得到button_pio外设虚拟地址
	button_pio_virtual_base = periph_virtual_base
			+ ((unsigned long) ( ALT_LWFPGASLVS_OFST + BUTTON_PIO_BASE)
					& (unsigned long) ( HW_REGS_MASK));
	*virtual_base = periph_virtual_base;	//将外设虚拟地址保存，用以释放时候使用
	return fd;
}
*/

int main(int argc, char ** argv) {

	int fd;
	int virtual_base = 0;	//虚拟基地址
	unsigned int button_edge;	//定义边沿捕获寄存器临时变量

	unsigned int led0 = 1, led1 = 1;

	//完成fpga侧外设虚拟地址映射
	fd = fpga_init(&virtual_base);

	printf("1\n");

	LED(7);

	printf("8\n");

	bool STOP = false;
	while(STOP == false)
	{
		//读取PIO边沿捕获寄存器以获知是否有检测到设定的边沿
		button_edge = *(button_pio_virtual_base + 3);



		switch (button_edge) {
		case 0x1:

			led0 = !led0; //对FPGA_LED 的bit0取反
			*(button_pio_virtual_base + 3) = 0x1; //清除边沿捕获寄存器的bit0位

			if (led0)
				*(led_pio_virtual_base + 0) = 0x2aa; //置位led_pio输出 1010101010

			else
				*(led_pio_virtual_base + 0) = 0x155; //清零led_pio输出 0101010101

			break;

		case 0x2:
			STOP = true;break;	//设置程序退出标志

		case 0x3:
			STOP = true;break;	//设置程序退出标志

		default:
			break;
		}
	}

	printf("2\n");

	while (1) {
		//读取PIO边沿捕获寄存器以获知是否有检测到设定的边沿
		button_edge = *(button_pio_virtual_base + 3);
		switch (button_edge) {
		case 0x1:
			led0 = !led0; //对FPGA_LED 的bit0取反
			*(button_pio_virtual_base + 3) = 0x1; //清除边沿捕获寄存器的bit0位
			if (led0)
				*(led_pio_virtual_base + 4) = 0x1; //置位led_pio的bit0输出
			else
				*(led_pio_virtual_base + 5) = 0x1; //清零led_pio的bit0输出
			break;

		case 0x2:
			led1 = !led1; //对FPGA_LED 的bit1取反
			*(button_pio_virtual_base + 3) = 0x2; //清除边沿捕获寄存器的bit1位
			if (led1)
				*(led_pio_virtual_base + 4) = 0x2;	//置位led_pio的bit1输出
			else
				*(led_pio_virtual_base + 5) = 0x2;	//清零led_pio的bit1输出
			break;

		case 0x3:
			led0 = !led0; //对FPGA_LED 的bit0取反
			led1 = !led1; //对FPGA_LED 的bit1取反

			//清除边沿捕获寄存器的bit0和bit1位
			*(button_pio_virtual_base + 3) = 0x3;

			//将led0和led1的状态直接写入led_pio数据寄存器
			*(led_pio_virtual_base + 0) = led1 * 2 | led0;
			break;

		default:
			break;
		}
	}

	//程序退出前，取消虚拟地址映射
	if (munmap(virtual_base, HW_REGS_SPAN) != 0) {
		printf("ERROR: munmap() failed...\n");
		close(fd);
		return (1);
	}

	close(fd); //关闭MPU
	return 0;
}

